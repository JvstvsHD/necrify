{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Necrify","text":"<p>Necrify is a Minecraft plugin designed for currentlyVelocity (and maybe Paper + Fabric in the future). It comprises many ways to manage punishments for server users such as bans and mutes and is currently translated for English and German. It also has capabilities for whitelist management.</p>","boost":2},{"location":"#why-necrify","title":"Why Necrify?","text":"<p>Necrify offers many easy-to-use commands with great auto-completion. If you want to style your reasons, you can use the MiniMessage format (You can try this out here):</p> <p></p> <p>You can preview reasons when hovering over the auto-completion</p> <p>The same applies for durations. Here, Necrify tells you when you're duration is not correct. More about that on  the commands page:</p> <p> </p> <p>Moreover, Necrify has a great API for developers to use. You can find more about that on the API usage page.</p>","boost":2},{"location":"#plugin-installation","title":"Plugin installation","text":"<ol> <li>Download the latest version of the plugin or download dev    builds here (may be unstable or not working)</li> <li>Put the downloaded file into the <code>plugins</code> folder of your server.</li> <li>(Re-)Start the server.</li> </ol> <p>Snapshot builds</p> <p>Snapshot builds are not stable and may contain bugs. They are not recommended for production use. Use them at your own risk and only for testing purposes.</p>","boost":2},{"location":"#mutes-on-velocity","title":"Mutes on Velocity","text":"<p>Mutes on Velocity</p> <p>TL;DR: Mutes are not working on Velocity anymore due to the 1.19.1 update. To still mute players, install the paper plugin on all of your paper servers.</p> <p>With the 1.19.1 Minecraft update, Minecraft's chat system got changed (detailed explanation). Since then, it is no longer possible to block chat messages in the ChatEvent of Velocity due to the signed chat messages. This is why the chat listener does not block any messages anymore which means mutes are effectively useless. A solution to this problem is developing an extension plugin for the actual game servers where cancelling these messages is still possible. Downloads for this paper plugin are found in the releases and also as dev builds on Jenkins. For further information about 1.19.1, please refer to the official release notes</p>","boost":2},{"location":"api-usage/","title":"How to use the API","text":""},{"location":"api-usage/#setup","title":"Setup","text":""},{"location":"api-usage/#installation","title":"Installation","text":"<p>Replace the version with the current version, e.g. 1.2.2. The latest version can be found in the top right corner right below the git repository name or here. Note that you only want to use the string after necrify-{platform}- and without the version build number.</p>"},{"location":"api-usage/#gradle-kotlin","title":"Gradle (kotlin)","text":"<pre><code>repositories {\n   mavenCentral()\n   maven(\"https://s01.oss.sonatype.org/content/repositories/snapshots\") // (1)\n}\n\ndependencies {\n    implementation(\"de.jvstvshd.necrify:necrify-api:1.2.2\")\n}\n</code></pre> <ol> <li>Only add this repository if you want to use the latest snapshot version.</li> </ol>"},{"location":"api-usage/#gradle-groovy","title":"Gradle (groovy)","text":"<pre><code>repositories {\n    mavenCentral()\n    maven { url = 'https://s01.oss.sonatype.org/content/repositories/snapshots' } // (1)\n}\n\ndependencies {\n   implementation 'de.jvstvshd.necrify:necrify-api:1.2.2'\n}\n</code></pre> <ol> <li>Only add this repository if you want to use the latest snapshot version.</li> </ol>"},{"location":"api-usage/#maven","title":"Maven","text":"<pre><code>&lt;repositories&gt;\n    &lt;repository&gt;\n        &lt;id&gt;sonatype-snapshots&lt;/id&gt;\n        &lt;name&gt;Sonatype Snapshots S01&lt;/name&gt;\n        &lt;url&gt;https://s01.oss.sonatype.org/content/repositories/snapshots&lt;/url&gt; &lt;!-- (1) --&gt;\n    &lt;/repository&gt;\n&lt;/repositories&gt;\n\n&lt;dependencies&gt;\n   &lt;dependency&gt;\n      &lt;groupId&gt;de.jvstvshd.necrify&lt;/groupId&gt;\n      &lt;artifactId&gt;necrify-api&lt;/artifactId&gt;\n      &lt;version&gt;1.2.2&lt;/version&gt;\n   &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre> <ol> <li>Only add this repository if you want to use the latest snapshot version.</li> </ol> <p>Snapshot builds</p> <p>Snapshot builds are not stable and may contain bugs. They are not recommended for production use. Use them at your own risk and only for testing purposes.</p>"},{"location":"api-usage/#concepts","title":"Concepts","text":"<p>The Necrify API revolves around the <code>Necrify</code> interface. It allows you to access the different parts of the plugin like  the user system. The central concept of Necrify is the <code>NecrifyUser</code> which represents a user on the server. This user can be banned, muted, kicked, etc. The punishments are represented by the <code>Punishment</code> interface which is implemented by the <code>Ban</code> and <code>Mute</code> classes. These classes represent the different types of punishments that can be issued to a user and offer methods to change or cancel the punishment.</p> <p>CompletableFuture#join</p> <p>On this page, when a method returns a <code>CompletableFuture</code>, there will be a #join call on it. This is done to simplify the code and to make it easier to understand. In a real-world scenario, you should use <code>CompletableFuture#whenComplete</code> or other methods that require a callback to be executed when the future is completed. Using #join or #get blocks the current thread and may lead to performance issues, especially in a server environment.</p>"},{"location":"api-usage/#first-steps","title":"First steps","text":""},{"location":"api-usage/#obtain-an-instance-of-the-api","title":"Obtain an instance of the API","text":""},{"location":"api-usage/#velocity","title":"Velocity","text":"<p>If you use the Velocity version, you can use the following code snippet to obtain an instance of the API: <pre><code>try {\n    Necrify necrify = (Necrify) server.getPluginManager()\n            .getPlugin(\"necrify\").orElseThrow().getInstance().orElseThrow();\n} catch(NoSuchElementException e) {\n    logger.error(\"Punishment API is not available\"); // (1)\n}\n</code></pre></p> <ol> <li>If the plugin is not available (yet), this will notify you about it in the console.</li> </ol> Managing the plugin dependencies correctly <p>You need to specify that you depend on Necrify so your plugin loads after Necrify. This is important because otherwise, Necrify may not be found since it gets loaded afterwards. <pre><code>    @Plugin(id = \"your-plugin\", name = \"Your Plugin\", version = \"1.0.0\", dependencies = {\n        @Dependency(id = \"necrify\")\n    })\n</code></pre></p> <p>More to come...</p>"},{"location":"api-usage/#punishing-a-player","title":"Punishing a player","text":"<p>All punishments are issued via the target user. For example, banning a player could be done this way:</p> <pre><code>    //Firstly, obtain the user instance\n    NecrifyUser user = api.getUserManager().getUser(uuid).orElseThrow(() -&gt; new NoSuchElementException(\"User not found\"));\n    MiniMessage miniMessage = MiniMessage.miniMessage();\n    //temporary ban:\n    Ban temporaryBan = user.ban(PunishmentDuration.parse(\n            miniMessage.deserialize(\"&lt;red&gt;You broke the server's rules! Don't cheat!\"), \n            PunishmentDuration.parse(\"1d\"))).join();\n    //1d equals 1 day, the duration is relative to the current time until the punishment is imposed.\n    //permanent ban:\n    Ban permanentBan = user.banPermanent(\n            miniMessage.deserialize(\"&lt;red&gt;You broke the server's rules again! You are not allowed to join someday again!\")\n    ).join();\n    //The ban instance you get via #join is the punishment that was issued. Note that using #join blocks the current \n    //Thread and since database operations take some time to complete, it is recommended to use #whenComplete or other.\n    //You can now use this instance to change or cancel the punishment:\n    temporaryBan.cancel().whenComplete((punishment, throwable) -&gt; {\n        if(throwable != null) {\n            logger.error(\"An error occurred while cancelling the punishment\", throwable);\n            return;\n        }\n        logger.info(\"The punishment was successfully cancelled\");\n    });\n    //#cancel should always return the same instance that you called the method on\n    //Event tough a permanent ban was issued for an indefinite time, you can still change the duration and the reason:        \n    permanentBan.change(PunishmentDuration.parse(\"300d\"), miniMessage.deseriaize(\"&lt;green&gt;Okay, you may join again in 300 days!\"))\n            .whenComplete((punishment, throwable) -&gt; {\n                if(throwable != null) {\n                    logger.error(\"An error occurred while changing the punishment\", throwable);\n                    return;\n                }\n                logger.info(\"The punishment was successfully changed\");\n    });\n</code></pre> Loading vs. getting users <p>In this example, UserManager#getUser(UUID) is used to get a user instance. This method only returns a user if the user is already loaded. If the user is not loaded, the method will return an empty optional. If you want to load the user if it is not already loaded, you can use UserManager#loadUser(UUID) which will load the user from the database if it is not already loaded. See more in the User API paragraph.</p> <p>Muting a player is similar, just replace 'ban' with 'mute'. Kicking a player can be done by calling <code>user.kick(Reason).join();</code> where it is safe to call #join since there is no database query done synchronously. This form of punishment cannot be changed nor cancelled as it only lasts a single moment.</p>"},{"location":"api-usage/#user-api","title":"User API","text":"<p>As mentioned before, the central concept of Necrify is the <code>NecrifyUser</code> which represents a user on the server. This user can be retrieved through the <code>UserManager</code> which is accessible via the <code>Necrify</code> instance. The <code>UserManager</code> offers methods to get a user by its UUID, name, or to load a user if it is not already loaded.</p> <p>Example</p> <p>This example shows how to get the user manager from the Necrify instance: <pre><code>UserManager userManager = necrify.getUserManager();\n</code></pre></p>"},{"location":"api-usage/#retrieving-users","title":"Retrieving users","text":"<p>Retrieving users is split into two ways: #loadUser(...) and #getUser(...). The difference between these two methods is that #getUser(...) only returns a user if it is already loaded. If the user is not loaded, the method will return an empty optional. #loadUser(...) on the other hand will load the user from the database if it is not already loaded. If the user is already loaded, the return value of the corresponding #getUser(...) method is returned. If the user is not loaded, the user is loaded from the database, after which the returned CompletableFuture is completed with the user instance.</p> #getUser(...)#loadUser(...) <p>#getUser(...) only returns a user if it is already loaded. If the user is not loaded, the method will return an empty optional.</p> <p>Example</p> <pre><code>Optional&lt;NecrifyUser&gt; user = userManager.getUser(uuid).join(); // (1)\nOptional&lt;NecrifyUser&gt; userByName = userManager.getUser(name).join(); // (2)\n</code></pre> <ol> <li>This will return the user identified by its UUID if it is already loaded. </li> <li>This will return the user identified by its name if it is already loaded.Note: This method may still return an empty optional     if the user's name is not stored.</li> </ol> <p>#loadUser(...) will load the user from the database if it is not already loaded. If the user is already loaded, the return value of the corresponding #getUser(...) method is returned. If the user is not loaded, the user is loaded from the database, after which the returned CompletableFuture is completed with the user instance.</p> <p>Example</p> <pre><code>Optional&lt;NecrifyUser&gt; user = userManager.loadUser(uuid).join(); // (1)\nOptional&lt;NecrifyUser&gt; userByName = userManager.loadUser(name).join(); // (2)\n</code></pre> <ol> <li>This will return the user identified by its UUID if it is already loaded. If the already is not loaded, the cached instance is returned.</li> <li>This will return the user identified by its name if it is already loaded. If the already is not loaded, the cached instance is returned. Note: This method may still return an empty optional if the user's name is not stored.</li> </ol> <p>You can query user's punishments by calling <code>NecrifyUser#getPunishments()</code> which returns a list of all punishments that were issued to the user. This list is immutable and cannot be modified. If you want to change or cancel a punishment, you need to use the corresponding methods on the punishment instance.</p>"},{"location":"api-usage/#other-usermanager-operations","title":"Other UserManager operations","text":"<p>You can also use the methods <code>#createUser(String|UUID)</code> to create a new user instance. You only need to supply either the UUID or the name of the user as this method will always fill out the other field. Necrify will create new user instances  automatically, so typically you don't need to use this method yourself.</p> <p>Creating a user</p> <p>This method always tries to create a new user instance in the database. At least for the provided plugins, only one user can exist per UUID. So, trying to create a user with an already existing UUID will result in an exception.</p> <p>Instead, is is more safe to use the <code>#loadOrCreateUser(String|UUID)</code> methods which will load the user if it is already existing or create a new user if it is not existing.</p> <p>Furthermore, you are able to get all users that are currently loaded by calling <code>#getLoadedUsers()</code> which returns a list of all users that are currently loaded. This list is immutable and cannot be modified.</p>"},{"location":"api-usage/#users-and-their-data","title":"Users and their data","text":"<p>If you have successfully obtained a user instance, you can access and modify the user's data. You cannot directly modify the UUID value of a user since this is a unique identifier for the user. You can, however, modify the user's name,  through calling <code>NecrifyUser#queryUsername(boolean)</code>, although this will only update the user name based on the given UUID. You may use the boolean parameter to determine whether the user's name should be updated in the database as well. If you choose to set this to false, you will only retrieve the current Minecraft username through Mojang's API.</p> <p>All methods that can be used to punish a user were mentioned previously.</p> <p>Necrify also offers whitelist management. You can check if a user is whitelisted by calling <code>NecrifyUser#isWhitelisted()</code>. To change this value, you can call <code>NecrifyUser#setWhitelisted(boolean)</code>. This will change the user's whitelist status to the desired value. If the player can no longer join and the whitelist is activated, they will be kicked automatically.</p> <p>If you want to delete a user, you can call <code>NecrifyUser#delete()</code>. This will delete the user from the database and remove it from the cache. This operation is irreversible and cannot be undone. Deleting a user will also delete all punishments that were issued to the user and all references in punishment logs. These may get replaced with a placeholder UUID. (Currently planned, implementation will follow in 1.2.3/1.3.0)</p>"},{"location":"api-usage/#punishment-api","title":"Punishment API","text":"<p>The punishment API is the central part of Necrify. It revolves around the <code>Punishment</code> interface which is extended by the TemporalPunishment interface. This interface is implemented by the <code>Ban</code> and <code>Mute</code> classes which represent the different types of punishments that can be issued to a user. The <code>Punishment</code> interface offers methods to change or cancel the punishment. The <code>TemporalPunishment</code> interface offers methods to manage punishments with a fixed expiration whilst <code>Punishment</code> offers general management options.</p> <p>A punishment may have the following properties (required properties are marked):</p> <ul> <li> Punishment ID (UUID) which is unique for each punishment</li> <li> A user reference which is the user that the punishment was issued to</li> <li> A reason which is a string that describes why the punishment was issued (in the Necrify plugin, this is serialized through MiniMessage)</li> <li> Creation date to control when the punishment gets enacted</li> <li> A type which identifies the punishment type (e.g. ban, mute, kick)</li> <li> An expiration (fixed only for temporal punishments; technically all have one, but that of permanent punishments is in a couple thousand years)</li> <li> successor punishments (value may be null)</li> </ul> <p>Those properties correspond to their setters and getters in the <code>Punishment</code> interface. You can change the reason (and the  duration for temporal punishment through <code>#change(...)</code>) and cancel the punishment through <code>#cancel()</code>. The <code>#punish()</code> method gets called when the punishment is issued. This method is called by the user instance when using the <code>#ban(...)</code> or <code>#mute(...)</code> methods and should not be called manually, only if you have newly created your own punishment instance.</p> <p>Moreover, temporal punishments offer </p>"},{"location":"api-usage/#punishment-logs","title":"Punishment logs","text":"<p>Punishment logs are a way to track all punishments that were issued to a user and changes that were made to the punishment. This includes the reason, the duration, the type, succession changes and the user that issued the punishment. The punishment logs are immutable and cannot be modified. You can access the punishment logs through the <code>Punishment#loadPunishmentLog()</code> method which returns an instance of <code>PunishmentLog</code>. Using its methods, you can retrieve log entries through various ways (depending on type/action, index or latest entry) and also create new ones.</p> <p>issuing own punishment log entries</p> <p>Entries of this system are issued automatically when a punishment is created, changed or cancelled. Issuing own entries can create inconsistencies in the system and confuse users. It is recommended to only use this system for reading purposes. Only create new entries when you are sure that the system is not able to do it itself.</p>"},{"location":"api-usage/#punishment-durations","title":"Punishment durations","text":"<p>A punishment duration stores the expiration of punishments. There are the following three types:</p> Relative durationFixed/absolute durationPermanent duration <p>This type of duration is relative to the current time. It is used to determine when the punishment should expire by adding the duration to the current time. This is useful for temporary punishments and also used in the commands. All relative durations become absolute durations when the action they are used for gets executed/stored.</p> <p>Example</p> <pre><code>PunishmentDuration duration = PunishmentDuration.parse(\"1d\"); // (1)\nPunishmentDuration relativeDuration = PunishmentDuration.fromMillis(1000); // (2)\n</code></pre> <ol> <li>This will create a new punishment duration that lasts for one day using the typical duration format also used for user input.</li> <li>This creates a new punishment duration that lasts for one second. Similar method exists for java.time.Duration.</li> </ol> <p>Absolute durations only contain a fixed expiration date. All durations become absolute when stored. All durations read from database contexts are absolute.</p> <p>Example</p> <pre><code>PunishmentDuration duration = PunishmentDuration.from(LocalDateTime.now().plusDays(1)); // (1)\n</code></pre> <ol> <li>This will create a new punishment duration that lasts until today plus one day. There exists a similar method for java.sql.Timestamp <code>#fromTimestamp</code>.</li> </ol> <p>Permanent durations are used for punishments that do not expire. Internally, their expiration date is set to December 31, 9999 and therefore is also a fixed duration. This is used for punishments that should last indefinitely.</p> <p>Example</p> <pre><code>PunishmentDuration duration = PunishmentDuration.PERMANENT; // (1)\n</code></pre> <ol> <li>This will create a new punishment duration that lasts indefinitely.</li> </ol> <p>You can easily convert between relative and absolute durations by calling <code>PunishmentDuration#absolute()</code> or <code>PunishmentDuration#relative()</code>. You can also check if a duration is permanent by calling <code>PunishmentDuration#isPermanent()</code>. The string representation used in user input can also be generated by calling <code>PunishmentDuration#remainingDuration()</code>. </p> <p>Use <code>PunishmentDuration#ofPunishment(Punishment)</code> to get the duration of a punishment. This will return the duration of the punishment if it is a temporal punishment and <code>PunishmentDuration.PERMANENT</code> otherwise.</p>"},{"location":"api-usage/#events-api","title":"Events API","text":"<p>Necrify offers an event system that allows you to listen to events that are fired by the plugin. The events are fired, for example, when a punishment is issued, changed, or cancelled. You can listen to these events through the <code>EventDispatcher</code>. The event dispatcher is accessible through the <code>Necrify</code> instance. You can register event listeners by calling <code>EventDispatcher#register(Object)</code>:</p> <p>Registering an event listener</p> <pre><code>EventDispatcher eventDispatcher = necrify.getEventDispatcher();\neventDispatcher.register(new YourEventListener());\n\neventDispatcher\n\nclass YourEventListener {\n    @Subscribe // (1)\n    public void onPunishmentIssued(PunishmentPersecutedEvent event) {\n        //Your code here\n    }\n}\n</code></pre> <ol> <li>This annotation is used to mark a method as an event listener. The method must have exactly one parameter which is the event that is fired.     Note: You have to use the annotation from org.greenrobot.eventbus.Subscribe and not from any other package.</li> </ol> <p>Event listening also works hierarchically regarding event class inheritance. This means that if you register an event listener for a superclass, it will also listen to events of subclasses. This is useful if you want to listen to all punishment events, for example. In this case, you can use the <code>PunishmentEvent</code> class as the parameter type for the event listener method. Look at the Javadocs to gain an overview</p> <p>You can unregister your listener by calling <code>EventDispatcher#unregister(Object)</code> and cancel event propagation by calling <code>EventDisptacher#cancel(NecrifyEvent)</code>. </p>"},{"location":"api-usage/#extending-the-api","title":"Extending the API","text":"<p>This introductory part is not implemented completely yet. It will be in 1.2.3.</p> <p>You can easily extend this API. First, you are able to exchange the implementations of the UserManager and, consequently, the User interface and message providers through the corresponding setters in the <code>Necrify</code> interface. This is useful if you want  to store additional data for the user or if you want to use a different storage system. Please note that this is only possible after <code>NecrifyPreInitializationEvent</code> has fired and before <code>NecrifyInitializedEvent</code> has fired.</p> <p>Regarding availability</p> <p>On Velocity, the initialisation of the plugin is done at the last possible point. Therefore, you can acquire the Necrify API instance directly in the initialization phase and directly register a listener for the PreInitializationEvent.</p>"},{"location":"api-usage/#punishment-log-types","title":"Punishment (log) types","text":"<p>A punishment's type is identified by an integer value. The following types are available per default (<code>StandardPunishmentType</code>): - 1: temporary ban - 2: permanent ban - 3: temporary mute - 4: permanent mute - 5: kick</p> <p>If you want to create new punishment types, you can use the <code>PunishmentTypeRegistry</code> class where you have to register your type with a unique integer value. This integer value must be unique and not already used by another type. You also have to provide a <code>PunishmentFactory</code> instance that is able to instantiate your punishment type. This factory is used to create new instances of punishments from a data map (<code>Map&lt;String, Object&gt;</code>). Per default, if you have not overwritten other core parts of Necrify, this contains the <code>duration</code> (<code>PunishmentDuration</code>), the <code>reason</code> (<code>String</code>), the user (<code>NecrifyUser</code>), the creation date/ <code>issued_at</code> (<code>LocalDateTime</code>), the <code>punishmentUuid</code> (<code>UUID</code>) and the <code>successor</code> (<code>UUID</code>) if available. Inconsistencies in this naming might get fixed in future versions, but with backwards compatibility in mind.</p>"},{"location":"commands/","title":"Necrify's commands","text":"<p>Necrify offers commands for all of its actions. This page provides detailed information about each command.  Per default, all commands are registered with the prefix <code>/necrify</code>. Moreover, it is possible to register top-level commands too by setting <code>allow-top-level-commands</code> to true (which is the default). This does not apply to the commands /necrify user and /necrify punishment.</p>","boost":2},{"location":"commands/#legend","title":"Legend","text":"","boost":2},{"location":"commands/#arguments","title":"Arguments","text":"<ul> <li><code>&lt;arg&gt;</code> denotes a required argument</li> <li><code>[arg]</code> denotes an optional argument</li> <li><code>player</code> as argument name means a player name OR uuid is required</li> <li><code>reason</code> means a reason that supports MiniMessage</li> <li><code>duration</code> as argument name means a duration</li> <li><code>punishment id</code> means the id of a punishment (UUID)</li> <li><code>--flag flag_value</code> denotes a flag with a value. These are always optional</li> </ul>","boost":2},{"location":"commands/#duration","title":"Duration","text":"<p>For temporal punishments, a duration must be specified. To be parsed by <code>PunishmentDuration#parse(String)</code>, a string must follow this scheme: <code>[n][s, m, h, d]</code> where <code>n</code> in the first bracket is a natural number and the second bracket denotes the unit of time: <code>s</code> - second(s), <code>m</code> - minute(s), <code>h</code> - hour(s), <code>d</code> - day(s).</p> <p>These values can be composed, all of them can be omitted. You can preview the expiration when hovering over the auto-completion.</p> <p>Examples</p> <ul> <li><code>1d12h15m30s</code> means a duration of 1 day, 12 hours, 15 minutes, and 30 seconds. </li> <li><code>1d</code> means a duration of 1 day.</li> <li><code>1h30m</code> means a duration of 1 hour and 30 minutes.</li> </ul>","boost":2},{"location":"commands/#command-overview","title":"Command overview","text":"<p>Every command can only be executed by players with the permission <code>necrify.command.&lt;command&gt;</code> or <code>necrify.admin</code> for all functions.</p>","boost":2},{"location":"commands/#ban","title":"ban","text":"<p>Usage: <code>/necrify ban &lt;player&gt; [reason]</code></p> <p></p> <p>This command bans a player permanently for the given reason or the default reason if no reason is specified.</p> Example command <ul> <li><code>/necrify ban Notch</code> bans the player Notch permanently.</li> <li><code>/necrify ban Notch Cheating</code> bans the player Notch permanently due to cheating.</li> </ul>","boost":2},{"location":"commands/#mute","title":"mute","text":"<p>Usage: <code>/necrify mute &lt;player&gt; [reason]</code></p> <p></p> <p>This command mutes a player permanently for the given reason or the default reason if no reason is specified.</p> Example command <ul> <li><code>/necrify mute Notch</code> mutes the player Notch permanently.</li> <li><code>/necrify mute Notch Spamming</code> mutes the player Notch permanently due to spamming.</li> </ul>","boost":2},{"location":"commands/#kick","title":"kick","text":"<p>Usage: <code>/necrify kick &lt;player&gt; [reason]</code></p> <p>This command kicks a player from the server for the given reason or the default reason if no reason is specified.</p> Example command <ul> <li><code>/necrify kick Notch</code> kicks the player Notch.</li> <li><code>/necrify kick Notch Cheating</code> kicks the player Notch due to cheating.</li> </ul>","boost":2},{"location":"commands/#tempban","title":"tempban","text":"<p>Usage: <code>/necrify tempban &lt;player&gt; &lt;duration&gt; [reason]</code></p> <p></p> <p>This command bans a player for the given duration for the given reason or the default reason if no reason is specified.</p> Example command <ul> <li><code>/necrify tempban Notch 30d</code> bans the player Notch for 30 days.</li> <li><code>/necrify tempban Notch 14d Cheating</code> bans the player Notch for 14 days due to cheating.</li> <li><code>/necrify tempban Notch 1d12h Cheating</code> bans the player Notch for 1 day and 12 hours due to cheating.</li> </ul> Multiple tempbans <p>If a player is already banned and then banned again, you will be asked if you want to chain the bans. Moreover, you will get this option for every existing ban that is still active. If you choose to chain the bans, the new ban will be put in a sort of idle state and only gets activated when the previous ban expires. This way, the player will be banned for the sum of all durations. If you choose not to chain the bans, the new ban will be applied immediately and run parallel to the existing ban(s): </p>","boost":2},{"location":"commands/#tempmute","title":"tempmute","text":"<p>Usage: <code>/necrify tempmute &lt;player&gt; &lt;duration&gt; [reason]</code></p> <p></p> <p>This command mutes a player for the given duration for the given reason or the default reason if no reason is specified.</p> Example command <ul> <li><code>/necrify tempmute Notch 30d</code> mutes the player Notch for 30 days.</li> <li><code>/necrify tempmute Notch 14d Spamming</code> mutes the player Notch for 14 days due to spamming.</li> <li><code>/necrify tempmute Notch 1d12h Spamming</code> mutes the player Notch for 1 day and 12 hours due to spamming.</li> </ul> Multiple tempmutes <p>Like bans, if a player is already muted and then muted again, you will be asked if you want to chain the mutes. Moreover, you will get this option for every existing mute that is still active. If you choose to chain the mutes, the new mute will be put in a sort of idle state and only gets activated when the previous mute expires. This way, the player will be muted for the sum of all durations. If you choose not to chain the mutes, the new mute will be applied immediately and run parallel to the existing mute(s): </p>","boost":2},{"location":"commands/#unban","title":"unban","text":"<p>Usage: <code>/necrify unban &lt;player&gt;</code></p> <p>This command unbans the given player. If multiple bans exist for the player, you will be asked which one you want to remove.</p> Example command <ul> <li><code>/necrify unban Notch</code> unbans the player Notch.</li> </ul> When multiple bans exist <p></p>","boost":2},{"location":"commands/#unmute","title":"unmute","text":"<p>Usage: <code>/necrify unmute &lt;player&gt;</code></p> <p>This command unmutes the given player. If multiple mutes exist for the player, you will be asked which one you want to remove.</p> Example command <ul> <li><code>/necrify unmute Notch</code> unmutes the player Notch.</li> </ul> When multiple mutes exist <p></p>","boost":2},{"location":"commands/#punishment","title":"punishment","text":"<p>Usage: <code>/necrify punishment &lt;punishment id&gt; &lt;cancel|remove|change|info|chain|log&gt; --chain other_punishment --page log_page</code></p> <p>This command manages punishments. The following subcommands are available:</p> <ul> <li>cancel or remove cancel the punishment just like the <code>unban</code> and <code>unmute</code> commands, but regardless of the punishment type.</li> <li> change changes the reason and/or duration of the punishment.</li> <li>info shows information about the punishment. You can still view this info after the punishment has expired, but you cannot cancel it anymore   and there will be no data about the punishment type:   </li> <li> <p>chain allows you to chain the punishment with another one. By doing this, one punishment gets put in an idle state    and only gets activated when the other one expires. You have to use this in combination with the <code>--chain</code> flag to provide the   punishment id of the other punishment.   This command will fail if:</p> <ul> <li>the two punishments' types are not compatible (e.g. you cannot chain a ban with a mute) </li> <li>the two punishments' users are not the same</li> <li>this chaining would create some sort of circular dependency (e.g. punishment B succeeds punishment A, now chaining C    with B so that C succeeds B (and A) is ok, but letting C succeed A would create a circular dependency)</li> </ul> </li> <li> <p>log shows the log of the punishment. You can use the <code>--page</code> flag to specify the page of the log you want to see.   This flag will also get used by the paginator appearing if you run this commands. Log data will be shown in the style of   old value -&gt; new value:   </p> </li> </ul> Example commands <ul> <li><code>/necrify punishment 12345678-1234-1234-1234-123456789abc info</code> shows information about the punishment</li> <li><code>/necrify punishment 12345678-1234-1234-1234-123456789abc cancel</code> cancels the punishment</li> <li><code>/necrify punishment 12345678-1234-1234-1234-123456789abc chain --chain 87654321-4321-4321-4321-432109876543</code> chains the punishment with another one</li> <li><code>/necrify punishment 12345678-1234-1234-1234-123456789abc log --page 2</code> shows the second page of the punishment log</li> </ul>","boost":2},{"location":"commands/#user","title":"user","text":"<p>Usage: <code>/necrify user &lt;player&gt; &lt;info|delete|whitelist&gt;</code></p> <p>This command is used to manage the users Necrify knows. The following subcommands are available:</p> <ul> <li>info shows information about a player's punishments and his whitelist status.   Note: something caused the English message to not display the whitelist status correctly. This will be fixed in the next update.   </li> <li>delete deletes this user including all punishments.</li> <li>whitelist inverts the whitelist status of the player. If the player is whitelisted, he will be blacklisted and vice versa.</li> </ul> Example commands <ul> <li><code>/necrify user Notch info</code> shows information about the player Notch</li> <li><code>/necrify user Notch delete</code> deletes the player Notch including all punishments</li> <li><code>/necrify user Notch whitelist</code> inverts the whitelist status of the player Notch</li> </ul>","boost":2},{"location":"commands/#reload","title":"reload","text":"<p>Usage: <code>/necrify reload</code></p> <p>This command reloads the plugin's configuration. This is useful if you want to apply changes to the configuration without  restarting the server like changing the default reason for bans and mutes or (de)activating the whitelist. If the reload fails, you will get a message in the console but the plugin will still work with the old configuration until the next restart.</p>","boost":2},{"location":"commands/#whitelist","title":"whitelist","text":"<p>Usage: <code>/necrify whitelist [status|on|off]</code></p> <p>This command shows the current whitelist status or changes it. If you want to change the status, you can use <code>on</code> to enable the whitelist or <code>off</code> to disable it.}If you want to see the status, you can use <code>status</code>. <code>on</code> and <code>off</code> are currently suspended. You currently need to change <code>whitelist-activated</code> in the configuration file to enable or disable the whitelist and then reload the plugin.</p> Example commands <ul> <li><code>/necrify whitelist status</code> shows the current whitelist status</li> <li><code>/necrify whitelist on</code> enables the whitelist currently suspended</li> <li><code>/necrify whitelist off</code> disables the whitelist currently suspended</li> </ul> <p>Last version of this page: according to plugin version 1.2.2</p>","boost":2},{"location":"configuration/","title":"Necrify's configuration","text":"<p>More is coming Soon <pre><code># Determines whether the whitelist should be active or not. If set to true, only users who are whitelisted may join.\nwhitelist-activated: false\n# Allows the registration of commands on a top-level, so /necrify ban is registered as well as plainly /ban.\n# /necrify user and /necrify punishment will not be registered as /user and /punishment.\nallow-top-level-commands: true\n# Sets the default language. This will be used as fallback option if the language of a user is not available.\ndefault-language: \"en\"\n\n# Controls settings regarding punishments\npunishment:\n  # Controls default messages for punishments. Message is the value to an ID. The IDs map as follows:\n  # 1 - permanent ban; 2 - temporary ban; 3 - permanent mute; 4 - temporary mute; 5 - kick\n  punishmentMessages:\n    1: \"&lt;red&gt;You are banned.\"\n    2: \"&lt;red&gt;You were permanently banned.\"\n    3: \"&lt;red&gt;You were muted.\"\n    4: \"&lt;red&gt;You were permanently muted.\"\n    5: \"&lt;red&gt;You were kicked.\"\n\n# Controls the usage of storage for user and punishment data.\n# See also in the wiki: https://github.com/JvstvsHD/necrify/wiki/Storage\ndatabase:\n  # Which host to take, e.g. localhost if the database is on the same machine or an IP address.\n  host: \"localhost\"\n  password: \"password\"\n  username: \"username\"\n  # Which database (scheme) to use\n  database: \"database\"\n  # The port on which the database server is running. 3306 is default for MySQL and MariaDB, 5432 for PostgreSQL.\n  port: \"5432\"\n  # The schema to use for the user and punishment data. This only applies to PostgreSQL and can be ignored for other dbs.\n  postgresSchema: \"punishment\"\n  # Which type of database to use. Currently only PostgreSQL, MariaDB and MySQL are supported.\n  sql-type: \"postgresql\"\n  # Determines how many connections should be kept open at maximum. If only one connection is open at the same time,\n  # this will limit the performance of the plugin as only one database transaction can be executed at the same time.\n  # If a low number of concurrent players/logins is expected, this can be set to a low number.\n  # Setting this to a higher value also increases the memory usage of the plugin.\n  max-pool-size: 5\n  # Determines how many idle connections should be kept open at minimum. As soon as the number of connections is below this\n  # number, HikariCP tries to open new connections as quickly and efficiently as possible.\n  min-idle: 2\n  # Determines whether the version of the database schema should be reset to the previous version. This avoids problems when\n  # a dev build is used and new additions to the database schema patch files are made afterwards and before the release. This\n  # will go only into effect when a dev build is used.\n  enable-development-version-reset: false\n</code></pre></p>","boost":2},{"location":"future/","title":"What's next","text":""},{"location":"future/#support-for-paper-and-fabric","title":"Support for Paper and Fabric","text":"<p>I plan to introduce full support for Paper and Fabric. The current platform-specific code for Velocity does not contain that much code. There are still some things that could be abstracted and put into a common module like the user system and database management. The Paper and Fabric versions of Necrify need to be able to sync data between themself and the Velocity version.</p>"},{"location":"future/#punishment-stages-and-templates-view-github-issue-here","title":"Punishment stages and templates (View Github Issue here)","text":"<p>Punishment templates would be one reason for a punishment identified by an identifier. This identifier would be used to set the punishment's reason and duration. This would be useful for servers that have a set of rules and want to have a consistent way of punishing users. This punishment then could be tracked by its identifier, and if the user gets punished  again with the same identifier, the next stage of the punishment would be applied. This would ease the process of managing punishments.</p>"},{"location":"future/#internalapi-features","title":"Internal/API features","text":""},{"location":"future/#return-tasks-instead-of-completablefuture","title":"Return tasks instead of CompletableFuture","text":"<p>This would allow additional data being available for Necrify tasks like the actor (which could fix  this issue). This would also allow for more control over the tasks and structure of task execution.</p>"},{"location":"future/#configuration","title":"Configuration","text":"<p>Using Configurate would allow for a more structured configuration file and easier access to the configuration values. It would also allow Necrify to keep the comments when saving the configuration file.</p> <p>Also, the current system of saving the default punishment reasons in the configuration file is not the best way to do it.</p>"},{"location":"storage/","title":"Storage","text":"<p>Necrify uses its configured to storage store information and data about its users and their punishments as well as the  current version of the database schema (only for internal use). Necrify supports multiple types of storages, though at  the moment only SQL-related ones. Currently supported are PostgreSQL, MySQL and MariaDB. There are currently no direct plans  to support SQLite or other non-SQL-derived file-based storage types since they are not compatible with the current storage structure.</p>","boost":0.5},{"location":"storage/#postgresql","title":"PostgreSQL","text":"<p>Download the latest version here\u2197.</p> <p>PostgreSQL (also referred to as 'Postgres') is the recommended mean of storage to use for Necrify plugins. Necrify requires  the PostgreSQL server to run with version 8.3 at least, but only version 12 and newer are officially supported. It is  recommended to use the latest version, at least of the running version. See here\u2197  for more information regarding this topic.</p>","boost":0.5},{"location":"storage/#mysql","title":"MySQL","text":"<p>Download the latest version here\u2197.</p> <p>Necrify requires the MySQL server to run with version 8.0.0 at least, though later versions probably contain important bug  fixes and may increase the overall performance. Lower versions do not support storing UUIDs directly in tables which is why the will not work.</p>","boost":0.5},{"location":"storage/#mariadb","title":"MariaDB","text":"<p>Download the latest version here\u2197.</p> <p>Necrify requires the MariaDB server to be of version 10.7 at least, though later versions probably contain important bug  fixes and may increase the overall performance. Lower versions do not support storing UUIDs directly in tables which is why the will not work.</p>","boost":0.5}]}